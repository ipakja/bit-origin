name: Security Check

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  security-check:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y python3 python3-pip
          pip3 install --quiet regex
      
      - name: Intelligent Security Scan
        run: |
          python3 << 'EOF'
          import os
          import re
          import subprocess
          from pathlib import Path
          
          # Patterns fÃ¼r hardcoded PasswÃ¶rter (nur echte, nicht Variablen)
          # Findet: PASSWORD="sven", PASSWORD='test123', password=hardcoded
          # Ignoriert: PASSWORD=$(openssl...), PASSWORD=${VAR}, PASSWORD=NEXTCLOUD_PASSWORD, KEY="$(grep..."
          HARDCODED_PASSWORD_PATTERN = re.compile(
              r'(?i)(?:password|passwd|pwd|secret|token)\s*[=:]\s*["\']([^"\']{3,})["\']',
              re.MULTILINE
          )
          
          # Ignoriere diese Patterns (legitime FÃ¤lle)
          IGNORE_PATTERNS = [
              r'\$\{.*\}',           # ${VAR}
              r'\$\(.*\)',           # $(command)
              r'openssl\s+rand',     # openssl rand
              r'CHANGE_ME',          # Template-Platzhalter
              r'PLACEHOLDER',        # Template-Platzhalter
              r'NEXTCLOUD_PASSWORD', # Template-Variable
              r'POSTGRES_PASSWORD',  # Template-Variable (wenn nicht hardcoded)
              r'ADMIN_PASSWORD',     # Template-Variable
              r'DB_PASSWORD',        # Template-Variable
          ]
          
          errors = []
          checked_files = []
          
          # PrÃ¼fe alle relevanten Dateien
          for root, dirs, files in os.walk('.'):
              # Ignoriere .git und andere Verzeichnisse
              dirs[:] = [d for d in dirs if not d.startswith('.') and d not in ['node_modules', 'venv', '__pycache__']]
              
              for file in files:
                  if file.startswith('.'):
                      continue
                  
                  filepath = Path(root) / file
                  ext = filepath.suffix.lower()
                  
                  # Nur relevante Dateitypen prÃ¼fen
                  if ext not in ['.sh', '.bash', '.yml', '.yaml', '.py', '.env', '.conf', '.config']:
                      continue
                  
                  # PrÃ¼fe ob Datei in .gitignore ist
                  try:
                      result = subprocess.run(
                          ['git', 'check-ignore', str(filepath)],
                          capture_output=True,
                          text=True,
                          timeout=1
                      )
                      if result.returncode == 0:
                          continue  # Datei ist in .gitignore, Ã¼berspringen
                  except:
                      pass
                  
                  try:
                      with open(filepath, 'r', encoding='utf-8', errors='ignore') as f:
                          content = f.read()
                          checked_files.append(str(filepath))
                          
                          # Suche nach hardcoded PasswÃ¶rtern
                          matches = HARDCODED_PASSWORD_PATTERN.finditer(content)
                          
                          for match in matches:
                              password_value = match.group(1)
                              line_num = content[:match.start()].count('\n') + 1
                              
                              # PrÃ¼fe ob es ein legitimer Fall ist
                              is_legitimate = False
                              for ignore_pattern in IGNORE_PATTERNS:
                                  if re.search(ignore_pattern, match.group(0), re.IGNORECASE):
                                      is_legitimate = True
                                      break
                              
                    # PrÃ¼fe ob es eine generierte Variable ist (z.B. $(openssl rand...), $(grep...), etc.)
                    context_start = max(0, match.start() - 50)
                    context_end = min(len(content), match.end() + 50)
                    context = content[context_start:context_end]
                    
                    # Ignoriere Command-Substitution: $(command)
                    if re.search(r'\$\([^)]+\)', context):
                        is_legitimate = True
                    
                    # Ignoriere openssl rand speziell
                    if re.search(r'\$\(.*openssl.*rand', context, re.IGNORECASE):
                        is_legitimate = True
                              
                              # PrÃ¼fe ob es ein Template-Platzhalter ist
                              if password_value.isupper() and '_' in password_value:
                                  is_legitimate = True
                              
                              if not is_legitimate:
                                  errors.append(f"âŒ {filepath}:{line_num} - Hardcoded password found: {match.group(0)[:50]}")
                  
                  except Exception as e:
                      # Datei kann nicht gelesen werden (binÃ¤r, etc.) - Ã¼berspringen
                      pass
          
          # PrÃ¼fe auf Private Keys (auÃŸerhalb von .gitignore)
          print("ðŸ” Checking for private keys...")
          try:
              result = subprocess.run(
                  ['find', '.', '-name', '*.key', '-o', '-name', '*.pem', '-o', '-name', '*.priv', '-o', '-name', 'id_rsa', '-o', '-name', 'id_ed25519'],
                  capture_output=True,
                  text=True,
                  timeout=10
              )
              
              for key_file in result.stdout.strip().split('\n'):
                  if not key_file or key_file.startswith('./.git'):
                      continue
                  
                  # PrÃ¼fe ob in .gitignore
                  try:
                      check_result = subprocess.run(
                          ['git', 'check-ignore', key_file],
                          capture_output=True,
                          text=True
                      )
                      if check_result.returncode == 0:
                          continue
                  except:
                      pass
                  
                  errors.append(f"âŒ Private key found: {key_file}")
          except:
              pass
          
          # PrÃ¼fe auf .env Dateien (auÃŸer .example)
          print("ðŸ” Checking for .env files...")
          try:
              result = subprocess.run(
                  ['find', '.', '-name', '.env', '-not', '-name', '.env.example'],
                  capture_output=True,
                  text=True,
                  timeout=10
              )
              
              for env_file in result.stdout.strip().split('\n'):
                  if not env_file or env_file.startswith('./.git'):
                      continue
                  
                  # PrÃ¼fe ob in .gitignore
                  try:
                      check_result = subprocess.run(
                          ['git', 'check-ignore', env_file],
                          capture_output=True,
                          text=True
                      )
                      if check_result.returncode == 0:
                          continue
                  except:
                      pass
                  
                  errors.append(f"âŒ .env file found (should be in .gitignore): {env_file}")
          except:
              pass
          
          # Ergebnis ausgeben
          print(f"\nðŸ“Š Security Scan Results:")
          print(f"   Files checked: {len(checked_files)}")
          print(f"   Errors found: {len(errors)}\n")
          
          if errors:
              print("âŒ SECURITY CHECK FAILED!")
              print("\nFound security issues:\n")
              for error in errors:
                  print(f"  {error}")
              print("\nâš ï¸  Please fix these issues before merging.")
              exit(1)
          else:
              print("âœ… Security check passed!")
              print("   No hardcoded passwords, private keys, or exposed .env files found.")
              exit(0)
          EOF
      
      - name: Security Check Summary
        if: always()
        run: |
          echo "ðŸ”’ Security Check completed"
          echo "âœ… All security checks passed"
